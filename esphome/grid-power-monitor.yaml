
esphome:
  name: grid-power-monitor
  friendly_name: Grid Power Monitor
  comment: Grid power inport/export display. Wemos D1 ESP32 with HT16K33 alpha numeric display
  on_boot:
    priority: 600
    then:
      - light.turn_on:
          id: led_strip 
          # effect: 'Scan 40ms'
          effect: 'Rainbow width 16'
          brightness: 50%
          red: 60%
          green: 0%
          blue: 100%
      - delay: 4s
      - light.turn_on:
          id: led_strip 
          effect: 'None'
          brightness: 5%
          red: 0%
          green: 0%
          blue: 0%
      - light.addressable_set:
          # clear all LEDs first
          id: led_strip
          range_from: 0
          range_to: 29
          red: 0%
          green: 0%
          blue: 0%

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:

api:
  encryption:
    key: Tb0+ns9tHseHGlGzpNaK0LOXuFJpWVfxYz08HwJvWAQ=

ota:
  password: 7c92edb13d764d70595085e3a110844d

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: 192.168.20.207
    gateway: 192.168.20.1
    subnet: 255.255.255.0

# I2C pins for the HT16K33 I2C 4-digit LED display
i2c:
  sda: GPIO21
  scl: GPIO22

external_components:
  - source:
      type: git
      url: https://github.com/ssieb/custom_components
    components: [ ht16k33_alpha ]
    
display:
  # https://github.com/ssieb/custom_components/tree/master/components/ht16k33_alpha
  - platform: ht16k33_alpha
    address: 0x70
    # update_interval: 1s
    scroll: False
    # scroll_speed: 200ms # time between each movement
    # scroll_dwell: 5s   # time to wait at the end before going back to the start
    # scroll_delay: 4   # the number of scroll_speed cycles to wait at the beginning before starting to scroll
    id: led_display
    lambda: |-
      float grid_power = id(ha_grid_power).state; // Note: Negative means exporting
      // if (grid_power < 0.0)
      //   it.printf("Grid EXP %.1fkW", -grid_power);
      // else
      //   it.printf("Grid IMP %.1fkW", grid_power);
      it.printf("%.1fkW", abs(grid_power));
      id(led_display).set_brightness( /* id(grid_power_led_strip_brightness).state */ 100.0 / 100.0); // brightness of the lcd_ht16k33 LED display [0.1 - 1.0]

button:
  - platform: restart
    name: ESP32 restart

# text_sensor:
#   - platform: template
#     name: Uptime
#     id: uptime_human
#     icon: mdi:clock-start

sensor:
  - platform: template
    name: Sim grid
    id: sim_grid

  - platform: homeassistant
    internal: true
    id: ha_grid_power
    entity_id: sensor.solarnet_power_grid
    
  - platform: homeassistant
    internal: true
    id: ha_solar_power
    entity_id: sensor.solarnet_power_photovoltaics

  - platform: homeassistant
    internal: true
    id: ha_house_power
    entity_id: sensor.solarnet_power_load

  # - platform: uptime
  #   name: Uptime
  #   internal: true
  #   id: uptime_sensor
  #   update_interval: 30s
  #   on_raw_value:
  #     then:
  #       - text_sensor.template.publish:
  #           id: uptime_human
  #           state: !lambda |-
  #             int seconds = round(id(uptime_sensor).raw_state);
  #             int days = seconds / (24 * 3600);
  #             seconds = seconds % (24 * 3600);
  #             int hours = seconds / 3600;
  #             seconds = seconds % 3600;
  #             int minutes = seconds /  60;
  #             seconds = seconds % 60;
  #             return (
  #               (days ? to_string(days) + "d " : "") +
  #               (hours ? to_string(hours) + "h " : "") +
  #               (minutes ? to_string(minutes) + "m " : "") +
  #               (to_string(seconds) + "s")).c_str();

  # - platform: wifi_signal
  #   name: WiFi Strength
  #   update_interval: 30s

light:
  - platform: neopixelbus
    id: led_strip
    name: LED strip
    internal: False
    variant: WS2812
    pin: GPIO23
    num_leds: 30
    type: RGB
    restore_mode: ALWAYS_OFF
    default_transition_length: 200ms
    effects:
      - addressable_color_wipe:
          name: Color Wipe Effect With Custom Values
          colors:
            - red: 0%
              green: 100%
              blue: 0%
              num_leds: 1
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_rainbow:
          name: Rainbow width 8
          speed: 10
          width: 8
      - addressable_rainbow:
          name: Rainbow width 16
          speed: 20
          width: 16
      - addressable_scan:
          name: Scan 40ms
          move_interval: 40ms
          scan_width: 1
      - strobe:
          name: Strobe Yellow
          colors:
            - state: true
              # brightness: 100%
              red: 100%
              green: 100%
              blue: 0%
              duration: 1.5s
            - state: false
              duration: 0.3s

globals:
  # saves the current number of SOLAR power LED segments
  - id: solar_leds
    type: int
    initial_value: '0'
  # saves the current number of HOUSE power LED segments
  - id: house_leds
    type: int
    initial_value: '0'

interval:
  - interval: 5sec
    then:
      - light.addressable_set:
          # Clear old settings out by turning off all LEDs
          id: led_strip
          range_from: 0
          range_to: 29
          color_brightness: 0%
          red: 0%
          green: 0%
          blue: 0%
      - light.addressable_set:
          # Display solar power
          # 1 LED = 1kW, max 10kW on LEDs 0-9
          id: led_strip
          color_brightness: !lambda 'return id(grid_power_led_strip_brightness).state / 100.0;'
          range_from: 0
          range_to: !lambda |-
            float solar_kw;
            // At night the solar sensor is "NaN" so check for it before using
            if (isnan(id(ha_solar_power).state)) {
              solar_kw = 0.0;
              id(solar_leds) = 0; // "range_to" will be -1 so no LEDs will be on
              ESP_LOGE("debug text", "solar = \"NaN\", solar_leds = %d", id(solar_leds));
            }
            else {
              // solar_kw = id(sim_solar).state;
              solar_kw = id(ha_solar_power).state;
              id(solar_leds) = (int)(solar_kw + 0.5);
              ESP_LOGI("debug text", "solar = %.2f kW, solar_leds = %d", solar_kw, id(solar_leds));
            }
            return id(solar_leds) - 1; // Note we store how many LEDs to light, not their "range_to"
          red: 100%
          green: 100%
          blue: 0%
      - light.addressable_set:
          # Display house power use
          # Use second part of LED string which is reversed at the half way point
          # 1 LED = 1kW, max 10kW on LEDs 19-10
          id: led_strip
          color_brightness: !lambda 'return id(grid_power_led_strip_brightness).state / 100.0;'
          range_to: 19 # start 1 LED at end of the strip - same as zero position for solar power
          range_from: !lambda |-
            float house_kw = -id(ha_house_power).state;
            // float house_kw = -id(sim_house).state;
            id(house_leds) = (int)(house_kw + 0.5);
            ESP_LOGI("debug text", "house = %.2f kW, house_leds = %d", house_kw, id(house_leds));
            return (20 - id(house_leds)); // reverse the LED direction for this value
          red: 0%
          green: 0%
          blue: 100%

      - light.addressable_set:
          # Display grid power
          # 1 LED = 1kW, max 10kW on LEDs 20-29
          # Negative is EXPORT (Green LED), Positive is IMPORT (Red LED)
          id: led_strip
          color_brightness: !lambda 'return id(grid_power_led_strip_brightness).state / 100.0;'

          range_from:  !lambda |-
            // Catch special case when both solar and house are both max 10kW
            if ((id(solar_leds) == 10) && (id(house_leds)) == 10) {
              int leds = 20;
              ESP_LOGW("debug text", "GRID range_from (Z)= %d", leds);
              return leds;
            }
            else if (id(solar_leds) > id(house_leds)) {
              int leds = 20 + id(house_leds);
              ESP_LOGW("debug text", "GRID range_from (A)= %d", leds);
              return leds;
            }
            else {
              int leds = 20 + id(solar_leds);
              ESP_LOGW("debug text", "GRID range_from (B)= %d", leds);
              return leds;
            }

          range_to: !lambda |-
            if (id(solar_leds) > id(house_leds)) {
              int leds = 20 + id(solar_leds) - 1;
              ESP_LOGW("debug text", "GRID range_to (C)= %d", leds);
              return leds;
            }
            else {
              int leds = 20 + id(house_leds) - 1;
              ESP_LOGW("debug text", "GRID range_to (D)= %d", leds);
              return leds;
            }
          red: !lambda |-
            if (id(solar_leds) < id(house_leds))
              return 1.0;
            else
              return 0.0;
          green: !lambda |-
            if (id(solar_leds) > id(house_leds))
              return 1.0;
            else
              return 0.0;
          blue: 0%

number:
  - platform: template
    name: "Grid power monitor LED brightness"
    id: grid_power_led_strip_brightness
    initial_value: 60
    optimistic: True
    min_value: 0
    max_value: 100
    step: 5
    mode: slider

  # To simulate SOLAR and HOUSE power
  # - platform: template
  #   name: Sim solar
  #   id: sim_solar
  #   initial_value: 3
  #   optimistic: True
  #   min_value: 0
  #   max_value: 10
  #   step: 0.25
  #   mode: slider
  #   on_value:
  #     then:
  #       - sensor.template.publish:
  #           id: sim_grid
  #           state: !lambda |-
  #             return -(x + id(sim_house).state);
  # - platform: template
  #   name: Sim house
  #   id: sim_house
  #   initial_value: -0.60
  #   optimistic: True
  #   min_value: -10
  #   max_value: 0
  #   step: 0.25
  #   mode: slider
  #   on_value:
  #     then:
  #       - sensor.template.publish:
  #           id: sim_grid
  #           state: !lambda |-
  #             return -(id(sim_solar).state + x);
