substitutions:
  touch_delay: 10ms
  icon_size: "72"
  dot_size: "4"

esphome:
  name: ${dev_name}
  friendly_name: ${friend_name}
  comment: M5Stack Core2 home power visualiser
  platformio_options:
    board_build.f_flash: 80000000L # set FLASH frequency to 80MHz
    board_build.partitions: default_16MB.csv
  on_boot: 
    priority: 600
    then:
      # This is needed otherwise setting to 100% later doesn't work, no idea why
      - lambda: "axp192_axp192component->set_brightness(0.5);"

external_components:
  # also try this custom component, has more features. e.g. 
  # should be able to set VBUS as an input from external +5V via (Grove port) using AXP192 GPIO0 ==> BUS_PW_EN / N_VBUSEN
  # https://gitlab.com/geiseri/esphome_extras/-/tree/main/components/axp192
  - source: github://Pionizer/pionizer-axp192
    components: [axp192]
    refresh: 1days

esp32:
  board: m5stack-core-esp32
  framework:
    type: arduino
  variant: ESP32
  flash_size: 16MB

logger:
  level: ERROR

api:
  encryption:
    key: !secret api_key

ota:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

globals:
  - id: touch_x
    type: int
    restore_value: no
    initial_value: "0"
  - id: touch_y
    type: int
    restore_value: no
    initial_value: "0"

sensor:
  - platform: axp192
    model: M5CORE2
    address: 0x34
    i2c_id: bus_a
    update_interval: 30s
    brightness: 100%
    battery_level:
      name: "Battery Level"
      id: batterylevel

  - platform: homeassistant
    internal: true
    id: ha_grid_power
    entity_id: sensor.solarnet_power_grid

  - platform: homeassistant
    internal: true
    id: ha_solar_power
    entity_id: sensor.solarnet_power_photovoltaics

  - platform: homeassistant
    internal: true
    id: ha_house_power
    entity_id: sensor.solarnet_power_load
    filters:
      - multiply: -1.0

  - platform: homeassistant
    internal: true
    id: ha_pool_pump_power
    entity_id: sensor.filtered_pool_pump_power_lowpass_filter

  - platform: homeassistant
    internal: true
    id: ha_pool_heater_power
    entity_id: sensor.pool_heater_power

  - platform: homeassistant
    internal: true
    id: ha_rack_power
    entity_id: sensor.19_rack_power_current_consumption

spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO38

i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    scan: True

font:
  - file: "arial.ttf"
    id: font_sml
    size: 20
  - file: "arial.ttf"
    id: font_med
    size: 25
  - file: "arial.ttf"
    id: font_lge
    size: 30

touchscreen:
  - platform: ft63x6
    i2c_id: bus_a
    interrupt_pin: 39
    id: touch_screen
    on_touch:
      # M5Stack Core2 is 320 x 240 + 40 pixels below display active area for 3x red circular touch buttons
      - lambda: |-
          // ESP_LOGE("touch", "Current (x,y) = %d, %d", touch.x, touch.y);        // y-coord is half of expected
          // ESP_LOGE("touch", "Raw (x,y) = %d, %d\n", touch.x_raw, touch.y_raw);  // y-coord is correct
          // float core2_val = axp192_axp192component->GetBatVoltage();
          // float core2_val = axp192_axp192component->GetVinVoltage();
          // float core2_val = axp192_axp192component->GetVBusVoltage();
          id(touch_x) = touch.x_raw; 
          id(touch_y) = touch.y_raw;
      - lambda: "axp192_axp192component->set_brightness(1.0);"

binary_sensor:
  - platform: touchscreen
    name: Button A
    id: btn_a
    internal: True
    x_min: 0
    x_max: 106
    y_min: 120 # should be 240, but is half due to bug in ESPHome touch y-coordinate
    y_max: 140 # should be 280
    filters:
      - delayed_on: ${touch_delay}
    on_press:
      - display.page.show: page1
      - component.update: lcd_display

  - platform: touchscreen
    name: Button B
    id: btn_b
    internal: True
    x_min: 107
    x_max: 213
    y_min: 120
    y_max: 140
    filters:
      - delayed_on: ${touch_delay}
    on_press:
      - display.page.show: page2
      - component.update: lcd_display
  
  - platform: touchscreen
    name: Button C
    id: btn_c
    internal: True
    x_min: 214
    x_max: 319
    y_min: 120
    y_max: 140
    filters:
      - delayed_on: ${touch_delay}
    # on_press:
    #   - display.page.show: page3
    #   - component.update: lcd_display

  - platform: homeassistant
    internal: true
    id: presence
    entity_id: ${room_light}
    on_press: 
      - lambda: "axp192_axp192component->set_brightness(1.0);"
    on_release:
      - lambda: "axp192_axp192component->set_brightness(0.5);"

color:
  - id: my_red
    red: 100%
    green: 0%
    blue: 0%
  - id: my_orange
    # 255, 128, 0
    red: 100%
    green: 50%
    blue: 0%
  - id: my_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: my_green
    red: 0%
    green: 100%
    blue: 0%
  - id: my_blue
    red: 0%
    green: 0%
    blue: 100%
  - id: mid_gray
    red: 50%
    green: 50%
    blue: 50%
  - id: dark_gray
    red: 20%
    green: 20%
    blue: 20%
  - id: my_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_cyan
    red: 0%
    green: 100%
    blue: 100%

display:
  - platform: ili9xxx
    model: M5STACK
    id: lcd_display
    # dimensions: "320X240"
    update_interval: 500ms
    cs_pin: 5
    dc_pin: 15
    pages:
      - id: page1
        lambda: |-
          int width = it.get_width();
          int height = it.get_height();
          int txt_xoffset = 5;
          int xx, yy = 0;

          auto grey = Color(128, 128, 128);
          auto grey_light = Color(50, 50, 50);
          auto white = Color(255, 255, 255);
          auto black = Color(0, 0, 0);
          auto orange = Color(255, 128, 0);
          auto yellow = Color(255, 255, 0);
          auto green = Color(0, 255, 0);
          auto cyan = Color(0, 255, 255);
          auto red = Color(255, 0, 0);

          // ***
          // *** Determine POWER
          // ***

          // *** DETERMINE SOLAR POWER
          // At night the solar sensor is "NaN" so check for it before using
          float solar_kw = 0.0;
          if (!isnan(id(ha_solar_power).state))
            solar_kw = id(ha_solar_power).state;
          // solar_kw = id(sim_solar).state; // Use number component to simulate solar power

          // DETERMINE HOUSE POWER
          //  Note: Negative means house consuming (should almost always be the case)
          float house_kw = 0.0;
          if (!isnan(id(ha_house_power).state))
            house_kw = id(ha_house_power).state;
          // house_kw = id(sim_house).state;   // Use number component to simulate house power

          // DETERMINE GRID POWER
          // Note: Negative = Export, Positive = Import
          float grid_kw = 0.0;
          if (!isnan(id(ha_grid_power).state))
            grid_kw = id(ha_grid_power).state;
          // grid_kw = id(sim_grid).state; // Use number component to simulate grid power

          // ***
          // *** Display images
          // ***
          it.image(width/2 - ${icon_size}/2, 0, id(img_sun));
          it.image(0, height - ${icon_size}, id(img_house));
          it.image(width - ${icon_size}, height - ${icon_size}, id(img_powerlines));

          // Dispaly units of kW
          xx = width - 23;
          yy = 18;
          it.filled_circle(xx, yy, 18, grey);
          it.print(xx, yy, id(font_sml), black, TextAlign::CENTER, "kW");

          // ***
          // *** Display POWER
          // ***

          // *** Display SOLAR power
          xx = width/2 - ${icon_size}/2 - txt_xoffset;
          yy = 15;
          it.printf(xx, yy, id(font_lge), yellow, TextAlign::RIGHT, "%.1f", solar_kw);

          // *** Display HOUSE power
          xx = 5;
          yy = height - ${icon_size} - 13;
          it.printf(xx, yy, id(font_lge), cyan, TextAlign::LEFT, "%.1f", house_kw);

          // ***
          // *** DETERMINE FLOWS
          // ***
          float flow_solar_house = 0.0;
          float flow_solar_grid = 0.0;
          if (solar_kw >= house_kw) {
            flow_solar_house = house_kw;
            flow_solar_grid = solar_kw - house_kw;
          }
          else
            flow_solar_house = solar_kw;


          // ***
          // *** DISPLAY FLOWS
          // ***
          
          // Flow line SOLAR-GRID
          it.line(width/2 + 15, ${icon_size} - 15, width - 50, height - ${icon_size} + 15, grey_light);
          // Flow line SOLAR-HOUSE
          it.line(width/2 - 15, ${icon_size} - 15, 50, height - ${icon_size} + 15, grey_light);
          // Flow line GRID-HOUSE
          yy = height - ${icon_size}/2;
          it.line(${icon_size}, yy, width - ${icon_size}, yy, grey_light);

          static int solar_grid_ind_x = width/2 + 15;
          static int solar_grid_ind_y = ${icon_size} - 15;
          // *** Display FLOW SOLAR-GRID
          if (flow_solar_grid > 0.05) {
            xx = (width * 3)/4 - 10;
            yy = height/2 - 30;
            it.printf(xx, yy, id(font_lge), green, TextAlign::LEFT, "%.1f", flow_solar_grid);

            // Display moving direction indicator
            if (solar_grid_ind_y >= (height - 60)) {
              solar_grid_ind_x = width/2 + 15;
              solar_grid_ind_y = ${icon_size} - 15;
            }
            it.filled_circle(solar_grid_ind_x, solar_grid_ind_y, ${dot_size}, green);
            solar_grid_ind_x += 6;
            solar_grid_ind_y += 8;
          }

          static int solar_house_ind_x = width/2 - 15;
          static int solar_house_ind_y = ${icon_size} - 15;
          // *** Display FLOW SOLAR-HOUSE
          if (flow_solar_house > 0.05) {
            xx = width/4 + 10;
            yy = height/2 - 30;
            it.printf(xx, yy, id(font_lge), green, TextAlign::RIGHT, "%.1f", flow_solar_house);

            // Display moving direction indicator
            if (solar_house_ind_y >= (height - 60)) {
              solar_house_ind_x = width/2 - 15;
              solar_house_ind_y = ${icon_size} - 15;
            }
            it.filled_circle(solar_house_ind_x, solar_house_ind_y, ${dot_size}, green);
            solar_house_ind_x -= 6;
            solar_house_ind_y += 8;
          }

          static int grid_house_ind_x = width - ${icon_size} - 5;
          // *** Display FLOW GRID-HOUSE
          if (grid_kw > 0.05) {
            xx = width/2;
            yy = height - ${icon_size}/2;
            // Only display Import flow
            it.printf(xx, yy - 25, id(font_lge), red, TextAlign::CENTER, "%.1f", grid_kw);

            if (grid_house_ind_x <= ${icon_size} + 5) {
              grid_house_ind_x = width - ${icon_size} - 5;
            }
            it.filled_circle(grid_house_ind_x, yy, ${dot_size}, red);
            grid_house_ind_x -= 10;
          }

      # - id: page3
        #  lambda: |-
      # //     auto grey = Color(128, 128, 128);
      # //     auto white = Color(255, 255, 255);
      # //     auto orange = Color(255, 128, 0);
      # //     auto yellow = Color(255, 255, 0);
      # //     auto green = Color(0, 255, 0);
      # //     auto cyan = Color(0, 255, 255);
      # //     auto red = Color(255, 0, 0);
      # //     auto color_var = Color(0, 0, 0);

      # //     int width = it.get_width();
      # //     int height = it.get_height();
      # //     int x_lab = 10;
      # //     const int y_lab_start = 32;
      # //     int y_lab = 0;
      # //     int y_inc = 32;
      # //     int x_val = 0;

      # //     it.rectangle(0, 0, width, height, grey);

      # //     // ***      Display Title
      # //     y_lab = y_lab_start;
      # //     it.print(width / 2, y_lab_start - 15, id(font_lge), white, TextAlign::CENTER, "Home Power");

      # //     // ***      Display labels
      # //     it.print(x_lab, y_lab, id(font_med), orange, "Solar:");

      # //     y_lab += (y_inc + 5);
      # //     it.print(x_lab, y_lab, id(font_med), orange, "Other (a/c, stove):");

      # //     y_lab += y_inc;
      # //     it.print(x_lab, y_lab, id(font_med), orange, "Pool Heater:");

      # //     y_lab += y_inc;
      # //     it.print(x_lab, y_lab, id(font_med), orange, "Pool Pump:");

      # //     y_lab += y_inc;
      # //     it.print(x_lab, y_lab, id(font_med), orange, "19\" Rack:");

      # //     y_lab += (y_inc + 5);
      # //     it.print(x_lab, y_lab, id(font_med), orange, "Total House:");

      # //     x_val = width - 5;
      # //     y_lab = y_lab_start;

      # //     // *** Display SOLAR power
      # //     if (!isnan(id(ha_solar_power).state))
      # //       it.printf(x_val, y_lab, id(font_med), yellow, TextAlign::RIGHT, "%.1f kW", id(ha_solar_power).state);
      # //     else
      # //       it.printf(x_val, y_lab, id(font_med), grey, TextAlign::RIGHT, "%s kW", "N/A");

      # //     // Divider line
      # //     y_lab += y_inc;
      # //     it.line(5, y_lab, x_val, y_lab, grey);
      # //     it.line(5, y_lab + 1, x_val, y_lab + 1, grey);
      # //     y_lab += 5;

      # //     // *** Display OTHER power (most likely the air conditioner)
      # //     float other_power = 0.0;
      # //     if (!isnan(id(ha_house_power).state)) {
      # //       other_power = id(ha_house_power).state - id(ha_pool_pump_power).state / 1000.0 - id(ha_pool_heater_power).state - id(ha_rack_power).state / 1000.0;
      # //       it.printf(x_val, y_lab, id(font_med), cyan, TextAlign::RIGHT, "%.1f kW", other_power);
      # //     }
      # //     else
      # //       it.printf(x_val, y_lab, id(font_med), grey, TextAlign::RIGHT, "%s kW", "N/A");

      # //     y_lab += y_inc;
      # //     // *** Display POOL HEATER power
      # //     if (!isnan(id(ha_pool_heater_power).state))
      # //       it.printf(x_val, y_lab, id(font_med), cyan, TextAlign::RIGHT, "%.1f kW", id(ha_pool_heater_power).state);
      # //     else
      # //       it.printf(x_val, y_lab, id(font_med), grey, TextAlign::RIGHT, "%s kW", "N/A");

      # //     y_lab += y_inc;
      # //     // *** Display POOL PUMP power
      # //     if (!isnan(id(ha_pool_pump_power).state))
      # //       it.printf(x_val, y_lab, id(font_med), cyan, TextAlign::RIGHT, "%.1f kW", id(ha_pool_pump_power).state / 1000.0);
      # //     else
      # //       it.printf(x_val, y_lab, id(font_med), grey, TextAlign::RIGHT, "%s kW", "N/A");

      # //     y_lab += y_inc;
      # //     // *** Display 19" RACK power
      # //     if (!isnan(id(ha_rack_power).state))
      # //       it.printf(x_val, y_lab, id(font_med), cyan, TextAlign::RIGHT, "%.1f kW", id(ha_rack_power).state / 1000.0);
      # //     else
      # //       it.printf(x_val, y_lab, id(font_med), grey, TextAlign::RIGHT, "%s kW", "N/A");

      # //     // Divider line
      # //     y_lab += y_inc;
      # //     it.line(5, y_lab, x_val, y_lab, grey);
      # //     it.line(5, y_lab + 1, x_val, y_lab + 1, grey);
      # //     y_lab += 5;

      # //     // *** Display Total power (House power)
      # //     if (!isnan(id(ha_house_power).state))
      # //       it.printf(x_val, y_lab, id(font_med), red, TextAlign::RIGHT, "%.1f kW", id(ha_house_power).state);
      # //     else
      # //       it.printf(x_val, y_lab, id(font_med), grey, TextAlign::RIGHT, "%s kW", "N/A");

      - id: page2
        lambda: |-
          auto grey = Color(128, 128, 128);
          auto white = Color(255, 255, 255);
          auto orange = Color(255, 128, 0);
          auto yellow = Color(255, 255, 0);
          auto green = Color(0, 255, 0);
          auto cyan = Color(0, 255, 255);
          auto red = Color(255, 0, 0);

          int width = it.get_width();
          int height = it.get_height();
          int x = 115;
          int y = 10;

          it.printf(width / 2, y, id(font_med), id(my_white), TextAlign::CENTER, "Home Solar / Power");
          it.graph(x, y + 20, id(power_graph)); // Optionally specifying color here sets the grid color

          // Display x-axis "(along y = zero), for graph with negative and positive values
          // y += (20 + (200 / 2));
          // it.line(x, y, width - 5, y, grey);
          // it.line(x, y + 1, width - 5, y + 1, grey);

          // Add y-axis labels
          x -= 6;
          y = 25;
          it.print(x, y, id(font_sml), orange, TextAlign::RIGHT, "12kW");
          y += 187;
          it.print(x, y, id(font_sml), orange, TextAlign::RIGHT, "0kW");

          // Add x-axis label, i.e. graph duration
          // y -= 80;
          x = 5;
          it.print(x + 6, y, id(font_sml), orange, "4 hrs");
          it.rectangle(x, y - 2, 56, 27, orange);

          // Display numeric values
          float solar = id(ha_solar_power).state;
          float house = id(ha_house_power).state;
          float grid = id(ha_grid_power).state;
          x = 7;
          y = 90;
          int y_inc = 25;

          it.printf(x, y, id(font_sml), yellow, TextAlign::LEFT, "Solar %.1f", solar);

          y += y_inc;
          it.printf(x, y, id(font_sml), cyan, TextAlign::LEFT, "House %.1f", house);

          y += y_inc;
          if (house > (solar + 0.05))
            it.printf(x, y, id(font_sml), red, TextAlign::LEFT, "Import %.1f", grid);
          else if (solar > (house + 0.05))
            it.printf(x, y, id(font_sml), green, TextAlign::LEFT, "Export %.1f", -grid);

graph:
  - id: power_graph
    duration: 4h
    width: 200 # leave a 5-pixel gap on either side of graph. Display width = 320 - 40 - (2 * 5)
    height: 200
    x_grid: 30min      # time / div
    y_grid: 2.0       # 2 kW / div
    min_value: 0.0
    max_value: 12.0 # Maximum y-axis value
    traces:
      - sensor: ha_solar_power
        line_type: SOLID
        line_thickness: 3
        color: my_yellow
      # - sensor: ha_grid_power
      #   line_type: SOLID
      #   line_thickness: 3
      #   color: my_blue
      - sensor: ha_house_power
        line_type: SOLID
        line_thickness: 3
        color: my_cyan

# interval:
#   - interval: 5s
#     then:
#       - display.page.show_next: lcd_display
#       - component.update: lcd_display

image:
  - file: "images/sun.png"
    id: img_sun
    resize: ${icon_size}X${icon_size}
    type: RGB24
    dither: FLOYDSTEINBERG
  - file: "images/house.png"
    id: img_house
    resize: ${icon_size}X${icon_size}
    type: RGB24
    dither: FLOYDSTEINBERG
  - file: "images/power3.png"
    id: img_powerlines
    resize: ${icon_size}X${icon_size}
    type: RGB24
    dither: FLOYDSTEINBERG
